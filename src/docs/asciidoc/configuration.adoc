
== Configuration

`HttpBuilder` configuration falls into two categories, the client configuration and the per-request configuration:

[source,groovy]
----
def request = HttpBuilder.configure {
    // Configure client or shared settings here (with HttpObjectConfig)
}.get {
    // Configure request here (with HttpConfig)
}
----

where in the example above, `get` could be replaced with any of the supported HTTP verbs (e.g. `get`, `head`, `post`, `put`,
`delete`).

There are two primary configuration interfaces, `HttpConfig` and `HttpObjectConfig`. The former is used across all
configuration methods, while the latter is used for the client-related configuration.

=== `HttpConfig`

The `HttpConfig` interface provides the public interface used for the `HttpBuilder` shared and per-verb configuration. It
provides accessors for request and response configuration with the `getRequest()` and `getResponse()` methods.

TIP: Request and Response configuration configured in the `configure` method will be applied to all requests made on the
`HttpBuilder` instance, unless the configuration is overridden in the request-specific configuration.

==== Request

The `HttpConfig.getRequest()` method returns an instance of `HttpConfig.Request` which may be used to configure various
properties of a request with either the Groovy DSL or a Java `Consumer`.

===== URI

The `setUri(String)` method of `HttpConfig.Request` is the only required configuration property of an `HttpBuilder` instance
since it defines the target URI for the request.

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:9191'
}
----

The URI may be extended in the request-specific configuration using the `getUri()` method, which returns an instance of
`groovyx.net.http.UriBuilder` populated with the URI information from the client configuration. This is useful to change the
path or query string information of the URI for a specific request, while leaving the base URI in the global configuration:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:9191'
}.get {
    request.uri.path = '/person'
    request.uri.query = [name: 'Bob']
}
----

===== Cookies

https://en.wikipedia.org/wiki/HTTP_cookie[HTTP Cookies] may be configured on a request using one of the cookie configuration
methods on the `HttpConfig.Request` interface:

* `cookie(String name, String value)` - Adds a cookie with the specified name and value to the request.
* `cookie(String name, String value, Date expires)` - Adds a cookie with the specified name, value and expiration date to the request (as `Date`).
* `cookie(String name, String value, LocalDateTime expires)` - Adds a cookie with the specified name, value and expiration date to the request (as `LocalDateTime`).

Cookies may be configured globally or per-request:

[source,groovy]
----
HttpBuilder.configure {
    request.cookie('user-id', 'some-identifier')
}.head {
    request.cookie('user-session', 'SDF@$TWEFSDT', new Date()+30)
}
----

===== Encoders

Content encoders are used to convert request body content to a different format before handing it off to the underlying HTTP
client. An encoder is implemented as a `java.util.function.BiConsumer<ChainedHttpConfig,ToServer>` function where the
provided implementation of the `ToServer` provides the data. See the `toServer(InputStream)` method.

Encoders are configured in the request configuration using the `encoder(String, BiConsumer<ChainedHttpConfig,ToServer>)` or
the `encoder(Iterable<String>, BiConsumer<ChainedHttpConfig,ToServer>)` method. The first parameter of each is the content
type(s) that the encoder should be applied to, while the second parameter is the encoder function itself.

Say we wanted to be able to send `Date` objects to the server in a specific format as the request body:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://locahost:1234/schedule'
    request.body = new Date()
    request.contentType = 'text/date-time'
    request.encoder('text/date-time'){ ChainedHttpConfig config, ToServer req->
        req.toServer(new ByteArrayInputStream("DATE-TIME: ${config.request.body.format('yyyyMMdd.HHmm')}".bytes))
    }
}.post()
----

Notice that a Groovy `Closure` is usable as a `BiConsumer` function. The `Date` object in the request is formatted as
`String`, converted to bytes and pushed to the request `InputStream`. The same example could be written in Java as:

[source,java]
----
HttpBuilder.configure(config -> {
    config.getRequest().setUri("http://locahost:1234/schedule");
    config.setBody(new Date());
    config.setContentType("text/date-time")
    config.getRequest().encoder("text/date-time", new BiConsumer<ChainedHttpConfig,ToServer>(){
        public void accept(ChainedHttpConfig cfg, ToServer ts){
            String converted = new SimpleDateFormat("yyyyMMdd.HHmm").format(config.getRequest().getBody());
            ts.toServer(new ByteArrayInputStream(("DATE-TIME: " + converted).getBytes()));
        }
    });
}).post();
----

Some default encoders are provided:

* CSV (when the `com.opencsv:opencsv:3.8` library is on the classpath)
* JSON (when either Groovy or the `com.fasterxml.jackson.core:jackson-databind:2.8.1` library is on the classpath)
* TEXT (with no additional libraries required)
* XML (without any additional libraries)
* Multipart (with client-specific implementations or when the JavaMail library is on the classpath)

Specific dependency versions are as of the writing of this document, see the project `build.gradle` dependencies block for
specific optional dependency versions.

> TODO: should document each encoder/decoder type (in a separate section)

===== Authentication

The `getAuth()` method of `HttpConfig.Request` provides configuration access to the two methods of authentication supported:
https://en.wikipedia.org/wiki/Basic_access_authentication[BASIC] and
https://en.wikipedia.org/wiki/Digest_access_authentication[DIGEST]. Each is configured in a similar manner with the
username and password to be sent with the request.

For BASIC:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:10101'
    request.auth.basic 'admin', 'myp@$$w0rd'
}
----

For DIGEST:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:10101'
    request.auth.digest 'admin', 'myp@$$w0rd'
}
----

There is nothing more to do on the client side.

WARNING: Currently, the OkHttp client will _only_ support DIGEST configuration in the `configure` method, not in the
request-specific configuration methods - this is due to how the client configures DIGEST support internally.

===== Content

The `HttpConfig.Request` interface has a few methods related to the request content:

* `setAccept(Iterable<String>)` and `setAccept(String[])` - specifies the https://en.wikipedia.org/wiki/List_of_HTTP_header_fields[Accept] header value.
* `setContentType(String)` - specifies the https://en.wikipedia.org/wiki/List_of_HTTP_header_fields[Content-Type] header value.
* `setCharset(Charset)` - specifies the https://en.wikipedia.org/wiki/List_of_HTTP_header_fields[Accept-Charset] header value.
* `setBody(Object)` - specifies the body content for the request.

An example would be:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:8675'
    request.contentType = 'text/plain'
    request.charset = Charsets.UTF_8
}.post {
    request.body = 'Let them eat content!'
}
----

Note that the body content and content-type come into play when configuring the request encoders; be sure that you have an
encoder configured to handle the type of content data you are providing and that it renders the data properly to the
request output.

===== Headers

Custom HTTP request headers may be configured directly using the `getHeaders()` method of the `HttpConfig.Request` instance.
A `Map<String,String>` is returned which may be used to add new headers or modify headers already configured on the request:

[source,groovy]
----
HttpBuilder.configure {
    request.headers['Global-Header'] = 'header-for-all'
}.post {
    request.headers['Custom-Header'] = 'some-custom-value'
}
----

These configured headers will be appended to the default request headers sent by the request (somewhat client-specific).

==== Response

The `HttpConfig.getResponse()` method returns an instance of `HttpConfig.Response` which may be used to configure various
properties of a request.

- exception
- failure
- parser
- success
- when

> TODO: fill in

=== `HttpObjectConfig`

The `HttpObjectConfig` interface is an extension of the `HttpConfig` interface, which provides additional client-level
configuration options. These options should be configured in the `HttpBuilder.configure` methods, rather than in the per-verb
configuration methods.

> TODO: client, execution

=== Client-Related

The client configuration (the `configure` method) consists of five different methods. The first two methods
`configure(Closure closure)` and `configure(Consumer<HttpObjectConfig> configuration)` instantiate and configure an
`HttpBuilder` object using the default client implementation, based on which `HttpBuilder` implementation is used. The
`HttpBuilder` and `JavaHttpBuilder` will use the core Java client, while the `ApacheHttpBuilder` and `OkHttpBuilder` classes
will use the Apache and OkHttp client implementations respectively.

The configuration `Closure` will delegate to an instance of `HttpObjectConfig` which provides the configuration DSL:

[source,groovy]
----
HttpBuilder.configure {
    request.uri = 'http://localhost:1234'
}
----

The configuration `Consumer<HttpObjectConfig>` will have an instance of `HttpObjectConfig` passed into it for configuration:

[source,java]
----
HttpBuilder.configure(config -> {
    config.getRequest().setUri("http://localhost:1234");
});
----

The other three methods `configure(Function<HttpObjectConfig,? extends HttpBuilder> factory)`,
`configure(Function<HttpObjectConfig,? extends HttpBuilder> factory, Closure closure)`, and
`configure(Function<HttpObjectConfig,? extends HttpBuilder> factory, Consumer<HttpObjectConfig> configuration)` have the same
function as ther other two (mentioned above); however, they have an additional `factory` property which is used to provide
the underlying HTTP client to be used. For the default `HttpURLConnection`-based implementation use the factory `Function`
as:

[source,groovy]
----
HttpBuilder.configure({ c -> new JavaHttpBuilder(c) })
----

For the Apache-based builder, you would use the `ApacheHttpBuilder` in the factory, as:

[source,groovy]
----
HttpBuilder.configure({ c -> new ApacheHttpBuilder(c) })
----

Using the `ApacheHttpBuilder` requires the `http-builder-ng-apache` dependency to be added to your project. The third client
implementation, `OkHttpBuilder` can be specified in the same manner (requiring the `http-builder-ng-okhttp` dependency).

=== Request-Related

The `HttpBuilder` class has request-specific configuration methods for each of the supported request verbs, `GET`, `HEAD`,
`DELETE`, `POST`, and `PUT`. Each request verb method has a synchronous and asynchronous version - the asynchronous versions
are suffixed with `Async`, (e.g. `headAsync`) and they return a `CompetableFuture` used to retrieve the eventual return value.
Otherwise, the async methods are the same. Only the synchronous versions are discussed below.

.Request Verb Configuration Methods
|===
| *Return Type* | *Arguments* | *Description*
| `Object` | _none_ | Executes a request with the verb equivalent of the method name. The configuration for the request will come fully from the client-configuration.
| `Object` | `Closure config` | Executes a request with the verb equivalent of the method name. The configuration for the request will come from the merging of the client and request configurations.
| `Object` | `Consumer<HttpConfig> config` | Executes a request with the verb equivalent of the method name. The configuration for the request will come from the merging of the client and request configurations.
| `<T> T` | `Class<T> type, Closure config` | Executes a request with the verb equivalent of the method name. The configuration for the request will come from the merging of the client and request configurations. The resonse content will be cast as the specified `type`.
| `<T> T` | `Class<T> type, Consumer<HttpConfig> config` | Executes a request with the verb equivalent of the method name. The configuration for the request will come from the merging of the client and request configurations. The resonse content will be cast as the specified `type`.
|===

In the table above, additional request-specific configuration may be applied as:

* The `Closure` arguments which will delegate to an instance of `HttpConfig`.
* The `Consumer<HttpConfig>` arguments which will have an instance of `HttpConfig` passed into them.

> FIXME: show an example of each configuration method type

> FIXME: Working above here

=== Interceptors

The `HttpObjectConfig` (used in the `configure()` method, allows the configuration of global request/response
interceptors, which can perform operations before and after every request/response on the client. For example,
if you wanted to make a POST request and return only the time elapsed during the request/response handling, you
could do something like the following:

[source,groovy]
----
import static groovyx.net.http.HttpBuilder.configure
import static groovyx.net.http.HttpVerb.GET

long elapsed = configure {
    request.uri = 'https://mvnrepository.com/artifact/org.codehaus.groovy/groovy-all'
    execution.interceptor(GET) { cfg, fx ->
        long started = System.currentTimeMillis()
        fx.apply(cfg)
        System.currentTimeMillis() - started
    }
}.get(Long, NO_OP)

println "Elapsed time for request: $elapsed ms"
----

This interceptor on the GET requests will calculate the time spent in the actual request handling (the
call to `fx.apply(cfg)` and return the elapsed time as the result of the request (ignoring the actual
response content from the server). The displayed result will be something like:

    Elapsed time for request: 865 ms

Using interceptors you can also modify the data before and after the `apply()` method is called.

=== Exception Handling

The main strategy for handling exceptions in the library, client implementations, or in the server response is:

1. By default allow exceptions to propagate.
2. If 1 is not feasible (because of interface restrictions, lambda restrictions, or too inconvenient), then exceptions should be wrapped in a `TransportingException` and re-thrown. The `TransportingException` is a signal to unwrap the exception before calling the exception handler.
3. In the Builders wrap all request/response executions inside a try/catch block. In the catch block(s) call `HttpBuilder.handleException()` to handle the exception and use the value returned from that method as the return value for the request/response.

This should ensure that the original exception thrown makes it to the exception handler. Handlers may be chained in a manner similar to the success/failure handlers.

Exception handlers are configured on the `HttpConfig` configuration object using the `exception(Closure)` or `exception(Function<Throwable,?>)` method
The value returned from the handler will be used as the result value of the request. Since there is no response body for the function to process, this
usually means that the function should do one of three things: re-throw the exception or throw a wrapped version of the exception, return null, or
return a predefined empty value.

[source,java]
----
HttpBuilder http = HttpBuilder.configure(config -> {
    config.getRequest().setUri("http://localhost:10101");
});
http.get( config -> {
    config.getRequest().getUri().setPath("/foo");
    config.getResponse().exception((t) -> {
         t.printStackTrace();
         throw new RuntimeException(t);
    });
});
----

The built in exception method wraps the exception in a `java.lang.RuntimeException (if it is not already of that type) and rethrows.

=== Ignoring SSL Issues

During testing or debugging of HTTPS endpoints it is often useful to ignore SSL certificate errors. HttpBuilder-NG provides
two methods of ignoring these issues. The first is via the configuration DSL using the
`groovyx.net.http.util.SslUtils::ignoreSslIssues(final HttpObjectConfig.Execution)` method.

[source,groovy]
----
import groovyx.net.http.JavaHttpBuilder
import static groovyx.net.http.util.SslUtils.ignoreSslIssues

def http = JavaHttpBuilder.configure {
    ignoreSslIssues execution
    // other config...
}
----

Applying this configuration helper will set an `SSLContext` and `HostnameVerifier` which will allow/trust all HTTP connections and ignore issues.
While this approach is useful, you may also need to toggle this feature at times when you do not, or cannot, change the DSL code itself; this is
why the second approach exists.

If the `groovyx.net.http.ignore-ssl-issues` system property is specified in the system properties with a value of `true`, the `ignoreSslIssues`
functionality will be applied by default.
